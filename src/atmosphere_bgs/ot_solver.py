import numpy as np
import _atmosphere_bgs
import matplotlib.pyplot as plt
from scipy.sparse import coo_array, dia_array
from scipy.sparse.linalg import spsolve
import time

class OTSolver:
    def __init__(self, input_data, ot_tol=1e-4, boundary_res=2000):
        
        self.y = input_data.y
        self.tm = input_data.tm
        self.tmn = input_data.tmn
        self.pp = input_data.pp
        self.sp = _atmosphere_bgs.SimulationParameters(area_tolerance=.2*ot_tol, 
                                                      line_tolerance=1e-4,
                                                      min_line_resolution=5,
                                                      boundary_res=boundary_res,
                                                      max_refine_steps=1000, 
                                                      smin=input_data.smin,
                                                      smax=input_data.smax,
                                                      pmin = input_data.pmin)
        self.ot_tol = ot_tol
        self.n = self.y.shape[0]
        self.runstats = None
        
    # initialisation
    def initialise_weights(self, phi_0=-1e+4):
        '''
        Given an (N,2) array of seeds y in (Z,Theta) coordinates, this function returns a weight vector phi such that 
        all cells in the dot-product-Laguerre tessellation generated by phi and the transformed seeds E 
        (defined in this function) are non-empty.

        Physical parameters used are a and Cp
        Simulation parameters used are zeta_max and zeta_min, the extents of the transformed source space lifted to 3d
        '''
        # define weights
        E = np.array([(0.5 / self.pp.a**2) * self.y[:,0]**2, self.pp.cp * self.y[:,1]]).T
        E_min, E_max = np.min(E, axis=0), np.max(E, axis=0)

        t_0 = 0.5 * E_max
        t_1 = self.pp.tf(_atmosphere_bgs.SimulationParameters().spmin)

        lmbd = 0.9 * 2 * min(1, np.min(np.array(self.pp.tf(self.sp.spmax)) - np.array(t_1))) / np.max(E_max - E_min, axis=0)
        t = lmbd * t_0 + t_1

        phi = E @ t - lmbd * 0.25 * np.linalg.norm(E, axis=1)**2

        phi = np.append(phi, phi_0)
        return phi

    def initialise_weights2(self, phi_0=-1e4):
        c = np.array([(1 / (2*self.pp.a**2)) * self.y[:,0]**2, 
                      self.pp.cp * self.y[:,1],
                      -self.pp.Omega * self.y[:,0]]).T
        
        c_max = np.max(c[:,:2], axis=0)
        c_min = np.min(c[:,:2], axis=0)
        
        z_min = self.pp.tf([max(0.01, self.sp.spmin[0]), np.maximum(10000, self.sp.spmin[1])])
        z_max = self.pp.tf([min(0.99, self.sp.spmax[0]), self.pp.p00])
        
        a = (z_max - z_min) / (c_max - c_min)
        b = z_min / a + c_max
        
        phi = -0.5 * np.sum(a[None,:] * (b[None,:] - c[:,:2])**2, axis=1) + c[:,2]
        
        return np.append(phi, phi_0)

    def get_bgs(self,
                use_long_double=False, verbose=False,
                max_its=1000, descent_accept_thresh=0.01,
                min_area=0, max_lost_areas=None,
                lr_up=2.0, lr_down=0.5, lr_max=1.0, lr_min=1e-20, lr_init=1e-5,
                max_loss_fraction=1e-3):
        """
        run the modified damped Newton solver
        
        Parameters:
        use_long_double : bool -- whether to use long double precision in critical parts of the calculation (default False)
        verbose : bool -- output information about the procedure during execution (default False)
        max_its : int -- maximal number of iterations to run the solver for (default 1000)
        descent_accept_thresh : float < 1 -- threshold of relative descent to accept step (default 0.01)
        min_area : float >= 0.0 -- minimal area to treat as non-empty (default 0)
        max_lost_areas : int >= 0 -- maximal number of cells that may be lost during an accepted step (default None, chosen based on problem size)
        lr_up : float > 1.0 -- factor by which to increase the learning rate (aka. step size) at the start of each iteration (default 2.0)
        lr_down : float < 1.0 -- factor by which to decrease the learning rate after a failed step (default 0.5)
        lr_max : float <= 1.0 -- upper bound for the learning rate (default 1.0)
        lr_min : float > 0 -- lower bound for the learning rate, when it falls below this, the solver is terminated (default 1e-20)
        lr_init : 0 < float <= 1 -- initial learning rate (default 1e-5)
        """
        
        err_goal = self.ot_tol/2
        
        # maximum number of areas to allow to be lost in an accepted step
        if max_lost_areas is None:
            max_lost_areas = int(np.ceil(self.n / 1000))
            
        lr = lr_init

        psi = self.initialise_weights(phi_0 = -1e10)

        if use_long_double:
            psi = psi.astype(np.float128)

        self.runstats = {"na" : [],  "lr" : [], "maxerr" : [], "l2err" : [], "meanerr" : [], "good" : [], "bad" : [], "tries" : []}
        self.timer = _atmosphere_bgs.Timer([])

        ld = _atmosphere_bgs.LaguerreDiagram(self.y, psi, self.pp, self.sp)
        psi = ld.touching_dual(randomize=True)
        self.timer += ld.time
        self.timer += ld.hs.time

        psi -= np.mean(psi)
        
        ld = _atmosphere_bgs.LaguerreDiagram(self.y, psi, self.pp, self.sp, ld.hints)
        err = np.abs(self.tmn - ld.areas)
        good_areas = (ld.areas > min_area)
        if verbose:
            print(f'it={-1}, lr={lr:.2e}, good_areas={np.sum(good_areas)}/{good_areas.shape[0]}')

        t00 = time.time()
        for it in range(max_its):

            jac = coo_array(ld.jac_coo(), shape=(self.n+1, self.n+1)).tocsr()[:-1,:-1]
            if self.sp.negative_area_scaling <= 0:
                jac += dia_array((1.0 - good_areas[None,:], [0]), shape=(self.n, self.n))
            d = spsolve(jac, (self.tmn - ld.areas))
            if self.sp.negative_area_scaling <= 0:
                d[~good_areas] = np.mean(d[good_areas]) - 1e9

            cnt_lost_areas_prev = self.n
            lr = np.minimum(lr_max, lr_up * lr)
            cnt_tries = 0
            while lr > lr_min:
                cnt_tries += 1
                # calculate step given step size lr
                psi2 = psi + lr * np.concatenate([d, [0]])

                if cnt_tries > 1:
                    self.timer += ld2.time
                    self.timer += ld2.hs.time
                
                # calculate ld after step
                ld2 = _atmosphere_bgs.LaguerreDiagram(self.y, psi2, self.pp, self.sp, ld.hints)
                err2 = np.abs(self.tmn - ld2.areas)
                good_areas2 = (ld2.areas > min_area)

                if self.sp.negative_area_scaling <= 0:
                    aerr = np.sum((err/self.tmn)[good_areas])
                    aerr2 = np.sum((err2/self.tmn)[good_areas])
                else:
                    aerr = np.sum((err/self.tmn))
                    aerr2 = np.sum((err2/self.tmn))

                cnt_lost_areas = np.sum(good_areas & ~good_areas2)
                if self.sp.negative_area_scaling <= 0:
                    areas_good = cnt_lost_areas <= max_loss_fraction * self.n or (cnt_lost_areas >= cnt_lost_areas_prev and cnt_lost_areas <= max_lost_areas)
                else:
                    areas_good = True
                cnt_lost_areas_prev = cnt_lost_areas

                # areas' ~= areas + lr * jac @ d
                #         = areas + lr * jac @ (jac-1 (tmn - areas))
                #         = areas + lr * (tmn - areas)
                #         = (1 - lr) * areas + lr * tmn
                # => ||areas' - tmn||_1 ~= (1 - lr) ||areas - tmn||_1
                descent_good = aerr2 < (1 - descent_accept_thresh * min(0.1, lr)) * aerr

                if areas_good and descent_good:
                    self.timer += ld.time
                    self.timer += ld.hs.time
                    # accept step
                    psi = psi2 - np.mean(psi2)
                    ld = ld2
                    err = err2
                    good_areas = good_areas2
                    break

                else:
                    # reject step
                    if verbose:
                        print(f"failed step at it {it}, lr {lr:.2e}, error {aerr:.10e} -> {aerr2:.10e}, areas_good: {areas_good} ({np.sum(good_areas)}, {np.sum(good_areas2)}, {np.sum(good_areas & ~good_areas2)}), descent_good: {descent_good}")
                    lr *= lr_down
                    continue

            if self.sp.negative_area_scaling <= 0 and not np.all(good_areas):
                good_areas_prev = good_areas
                if verbose:
                    print(f"try to fix {np.sum(~good_areas_prev)} bad area(s)")
                    
                psi = ld.touching_dual(randomize=True)
                self.timer += ld.time
                self.timer += ld.hs.time
                ld = _atmosphere_bgs.LaguerreDiagram(self.y, psi, self.pp, self.sp, ld.hints)
                err = np.abs(self.tmn - ld.areas)
                good_areas = (ld.areas > min_area)

                if verbose:
                    print(f"managed to fix {np.sum(good_areas & ~good_areas_prev)} and broke {np.sum(good_areas_prev & ~good_areas)}")

            if lr <= lr_min:
                raise RuntimeError("can not find sufficiently small learning rate")

            self.ld = ld
            
            self.runstats["lr"] += [lr]
            self.runstats["maxerr"] += [np.max(err / self.tmn)]
            self.runstats["l2err"] += [np.sum((err / self.tmn)**2)**.5]
            self.runstats["meanerr"] += [np.mean(err / self.tmn)]
            self.runstats["good"] += [np.sum(good_areas)]
            self.runstats["bad"] += [good_areas.shape[0] - self.runstats["good"][-1]]
            self.runstats["tries"] += [cnt_tries]

            if verbose:
                print(f'it={it}, lr={lr:.2e}, good_areas={self.runstats["good"][-1]}/{good_areas.shape[0]}, meanerr={self.runstats["meanerr"][-1]:.6e}, l2err = {self.runstats["l2err"][-1]:.6e}, max_err={self.runstats["maxerr"][-1]:.6e}')

            if np.max(err / self.tmn) < err_goal:
                break

        t11 = time.time()
        if verbose:
            print(f"finished in {t11 - t00:.2f}s")

        self.timer += ld.time
        self.timer += ld.hs.time
            
        # assign variables to class
        self.ld = ld
        return ld
    
    def plot_runstats(self):
        """
        plot the behavior of the last run
        """
        
        if self.runstats is None:
            return
        
        # plot convergence behavior
        fig, axs = plt.subplots(3, 1, figsize=(10, 2*3), dpi=200, sharex=True, tight_layout=True)

        pi = 0
        axs[pi].set_yscale("log")
        axs[pi].set_ylabel("lr")
        axs[pi].plot(self.runstats["lr"], label="step size")
        axs[pi].legend(loc="upper right")

        pi += 1
        axs[pi].set_ylabel("err")
        axs[pi].plot(self.runstats["maxerr"], label="max")
        axs[pi].plot(self.runstats["l2err"], label="l2")
        axs[pi].plot(self.runstats["meanerr"], label="mean")
        axs[pi].set_yscale("log")
        axs[pi].legend(loc="upper right")

        pi += 1
        axs[pi].set_ylabel("count")
        axs[pi].plot(self.runstats["bad"], label="bad areas")
        axs[pi].plot(self.runstats["tries"], label="step tries")
        axs[pi].legend(loc="upper right")
        
