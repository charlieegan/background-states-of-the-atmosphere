import numpy as np
import atmosphere_bgs
import matplotlib.pyplot as plt
from scipy.sparse import coo_array
from scipy.sparse.linalg import spsolve
import time

class ot_solver:

    def __init__(self,input_data, OT_tol = 1e-4):
        
        self.y = input_data.y
        self.tm = input_data.tm
        self.tmn = input_data.tmn
        self.pp = input_data.pp
        
        self.sp = _atmosphere_bgs.SimulationParameters(area_tolerance=.2*OT_tol, 
                                                      line_tolerance=1e-4,
                                                      min_line_resolution=4,
                                                      boundary_res=2000,
                                                      max_refine_steps=1000, 
                                                      smin=input_data.smin,
                                                      smax=input_data.smax,
                                                      pmin = input_data.pmin)
        self._OT_tol = OT_tol
        
    @property
    def OT_tol(self):
        return self._OT_tol
        
    # initialisation
    def initialise_weights(self, phi_0 = -1e+4):
        '''
        Given an (N,2) array of seeds y in (Z,Theta) coordinates, this function returns a weight vector phi such that 
        all cells in the dot-product-Laguerre tessellation generated by phi and the transformed seeds E 
        (defined in this function) are non-empty.

        Physical parameters used are a and Cp
        Simulation parameters used are zeta_max and zeta_min, the extents of the transformed source space lifted to 3d
        '''
        y = self.y
        pp = self.pp
        sp = self.sp

        # define weights
        E = np.array([(1/2/pp.a**2)*y[:,0]**2, pp.cp*y[:,1]]).T
        F = -E/2

        F_min = np.min(F,axis=0)
        F_max = np.max(F,axis=0)

        zeta_min = [*pp.tf(sp.spmin),-1e50]
        zeta_max = [*pp.tf(sp.spmax), 1e50]

        t_0 = -F_min
        t_1 = zeta_min[:2]
        t_1 = pp.tf(_atmosphere_bgs.SimulationParameters().spmin)

        lmbd = 0.9*min(1,np.min(np.array(zeta_max[:2]) - np.array(t_1)))/np.max(F_max - F_min,axis=0)
        t = lmbd*t_0 + t_1
        #print(t)

        chi = -2*F@t - (lmbd-1)*np.linalg.norm(F,axis=1)**2
        phi = chi - np.linalg.norm(E,axis=1)**2/4

        phi = np.append(phi,phi_0)
        return phi

    def initialise_final_weight(self,psi):
        '''find value of psi[-1] to just barely be non-empty'''
        y = self.y
        pp = self.pp
        sp = self.sp
        
        ld = _atmosphere_bgs.LaguerreDiagram(y, psi, pp, sp)

        # top edges (adjacent to upper p-boundary)
        te = [e for e in ld.hs.mesh.padj[4] if e.pj >= 6]

        psi0 = np.inf

        for e in te:
            yi = y[e.pj - 6]
            zeta0 = ld.hs.mesh.dvert[e.di]
            zeta1 = ld.hs.mesh.dvert[e.dj]

            c0 = yi[0]**2 / (2 * pp.a**2) * zeta0[0] + pp.cp * yi[1] * zeta0[1] - pp.Omega * yi[0] + 0.5 * pp.Omega**2 * pp.a**2 / zeta0[0]
            c1 = yi[0]**2 / (2 * pp.a**2) * zeta1[0] + pp.cp * yi[1] * zeta1[1] - pp.Omega * yi[0] + 0.5 * pp.Omega**2 * pp.a**2 / zeta1[0]

            psi0 = np.min([psi0, psi[e.pj - 6] - c0, psi[e.pj - 6] - c1])

        psi[-1] = psi0 + 100 # 5000

        return psi

    # Damped newton solver
    def get_bgs(self,use_long_double=False):
        
        y = self.y
        tmn = self.tmn
        pp = self.pp
        sp = self.sp
        err_goal = self.OT_tol/2
        psi = self.initialise_weights(phi_0 = -1e10)

        if use_long_double:
            psi = psi.astype(np.float128)

        psi = self.initialise_final_weight(psi)

        # run dampened newton
        n = y.shape[0]

        descent_accept_thresh = 0.01  # minimal relative descent slope

        min_area = 1e-9

        lr_up = 4
        lr_down = 0.5
        lr_max = 1
        lr_min = 1e-20

        max_its = 1000

        lr = 1e-5

        runstats = {"na" : [],  "lr" : [], "maxerr" : [], "l2err" : [], "meanerr" : [], "good" : [], "bad" : []}

        ld = _atmosphere_bgs.LaguerreDiagram(y, psi, pp, sp)
        err = np.abs(tmn - ld.areas)
        good_areas = (ld.areas > min_area)
        jac = coo_array(ld.jac_coo(), shape=(n+1,n+1)).tocsr()[:-1,:-1]
        jac.setdiag(np.where(good_areas, jac.diagonal(), 1))
        d = spsolve(jac, (tmn - ld.areas))
        d[~good_areas] = np.mean(d[good_areas]) - 1e9

        print(f'it={-1}, lr={lr:.2e}, good_areas={np.sum(good_areas)}/{good_areas.shape[0]}')

        t00 = time.time()
        for it in range(max_its):

            lr = np.minimum(lr_max, lr_up * lr)
            while lr > lr_min:
                # calculate step given step size lr
                psi2 = psi + lr * np.concatenate([d, [0]])

                # calculate ld after step
                ld2 = _atmosphere_bgs.LaguerreDiagram(y, psi2, pp, sp)
                err2 = np.abs(tmn - ld2.areas)
                good_areas2 = (ld2.areas > min_area)

                aerr = np.sum((err/tmn)[good_areas]**2)**.5
                aerr2 = np.sum((err2/tmn)[good_areas]**2)**.5

                areas_good = np.sum(good_areas & ~good_areas2) < 3 #np.sum(good_areas2) >= np.sum(good_areas) - 10 #
                descent_good = aerr2 < (1 - descent_accept_thresh * lr) * aerr

                if areas_good and descent_good:
                    # accept step
                    #print(f"accept step at it {it}, lr {lr:.2e}, error {aerr:.10e} -> {aerr2:.10e}")
                    psi = psi2
                    ld = ld2
                    err = err2
                    good_areas = good_areas2
                    jac = coo_array(ld.jac_coo(), shape=(n+1,n+1)).tocsr()[:-1,:-1]
                    jac.setdiag(np.where(good_areas, jac.diagonal(), 1))
                    d = spsolve(jac, (tmn - ld.areas))
                    d[~good_areas] = np.mean(d[good_areas]) - 1e9
                    break

                else:
                    # reject step
                    print(f"failed step at it {it}, lr {lr:.2e}, error {aerr:.10e} -> {aerr2:.10e}, areas_good: {areas_good} ({np.sum(good_areas)}, {np.sum(good_areas2)}, {np.sum(good_areas & ~good_areas2)}), descent_good: {descent_good}")
                    lr *= lr_down
                    continue

            if not np.all(good_areas):
                good_areas_prev = good_areas
                print(f"try to fix {np.sum(~good_areas_prev)} bad area(s)")

                psi[:-1] = ld.touching_dual(randomize=True)

                ld = _atmosphere_bgs.LaguerreDiagram(y, psi, pp, sp)
                err = np.abs(tmn - ld.areas)
                good_areas = (ld.areas > min_area)
                jac = coo_array(ld.jac_coo(), shape=(n+1,n+1)).tocsr()[:-1,:-1]
                jac.setdiag(np.where(good_areas, jac.diagonal(), 1))
                d = spsolve(jac, (tmn - ld.areas))
                d[~good_areas] = np.mean(d[good_areas])

                print(f"managed to fix {np.sum(good_areas & ~good_areas_prev)} and broke {np.sum(good_areas_prev & ~good_areas)}")


            if lr <= lr_min:
                print("ERROR: can not find sufficiently small learning rate")
                break

            runstats["lr"] += [lr]
            runstats["maxerr"] += [np.max(err / tmn)]
            runstats["l2err"] += [np.sum((err / tmn)**2)**.5]
            runstats["meanerr"] += [np.mean(err / tmn)]
            runstats["good"] += [np.sum(good_areas)]
            runstats["bad"] += [good_areas.shape[0] - runstats["good"][-1]]

            print(f'it={it}, lr={lr:.2e}, good_areas={runstats["good"][-1]}/{good_areas.shape[0]}, meanerr={runstats["meanerr"][-1]:.6e}, l2err = {runstats["l2err"][-1]:.6e}, max_err={runstats["maxerr"][-1]:.6e}')

            if np.max(err / tmn) < err_goal:
                break

        t11 = time.time()

        # plot convergence behavior
        fig, axs = plt.subplots(3, 1, figsize=(10,2*2), dpi=200, sharex=True, tight_layout=True)

        pi = 0
        axs[pi].set_yscale("log")
        axs[pi].set_ylabel("lr")
        axs[pi].plot(runstats["lr"])

        pi += 1
        axs[pi].set_ylabel("err")
        axs[pi].plot(runstats["maxerr"], label="max")
        axs[pi].plot(runstats["l2err"], label="l2")
        axs[pi].plot(runstats["meanerr"], label="mean")
        axs[pi].set_yscale("log")
        axs[pi].legend(loc="upper right")

        pi += 1
        axs[pi].set_ylabel("count")
        axs[pi].plot(runstats["bad"], label="bad areas")
        axs[pi].legend(loc="upper right")
        
        # assign variables to class
        self.ld = ld

        return ld
